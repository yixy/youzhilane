# 架构之路(03)——缓存设计 #

## 1. 缓存应用场景 ##

系统设计中需要合理的使用缓存，一般需符合如下场景。

* 热点数据缓存或（少量数据下）全部缓存：一般，数据没有热点不适合使用缓存，经验值是符合二八定律（80%的访问落在20%的数据上）的数据分布使用缓存才有意义。如果只为了提高读效率缓存全量数据，此时不存在内存置换，这样也是可行的，但是考虑到内存价格，在数据量大时性价比不高。
* 读写比高：频繁修改的数据不适合使用缓存，经验值是数据读写比在2:1以上，缓存才有意义。

计算机世界中，单机系统或者分布式系统都会使用到缓存，下面从单机系统开始进行缓存设计分析。

## 2. 单机系统中的cache存储器 ##

在计算机系统中，容量较小、速度较快的cache（可能有多级，分别为片内cache和片外cache）和容量较大、速度较慢的主存连在一起，cache中存放主存数据的部分副本。CPU试图从主存读取一个字时，检查cache中是否存放了对应副本，有的话将cache中存储的字传送给CPU，否则从主存中将该份数据读入cache，再将该字传送给CPU。

缓存命中算法






缓存本质上的实现是一个Hash表用于存放热点数据，Hash表的读写时间复杂度是O(1)。


一般的缓存查询流程：

1. 判断缓存是否有数据，有的话读缓存/cache，否则读数据库/主存
2. 数据库为空则直接返回
3. 数据库不为空则写缓存并返回客户端

## 2. 缓存更新：设置超时点 ##

缓存更新一般涉及两种实现思路：设置超时点和立即更新（双写）。这里先介绍第一种实现。

* 设置超时点：缓存数据设置超时时间，超时后从缓存中删除，等到下次要读取该数据时再写入缓存。注意，这种场景可能导致脏读。

删除超时缓存的方式有定期删除和惰性删除。

* 定时删除：在这是键的过期时间的同时，创建一个定时器 Timer，让定时器在键过期时间来临时立即执行对过期键的删除。
* 惰性删除：键过期后不管，每次读取该键时，判断该键是否过期，如果过期删除该键返回空。

定期删除对内存友好，对 CPU 不友好，如果过期删除的键比较多的时候，删除键这一行为会占用相当一部分 CPU 性能，对缓存 的吞吐量造成一定影响。惰性删除对 CPU 友好，内存不友好。如果很多键过期了，但在将来很长一段时间内没有很多客户端访问该键导致过期键不会被删除，占用大量内存空间。

以redis为例，redis采用的是定期删除+惰性删除策略。具体操作如下：

* Redis 会将每一个设置了 expire 的键存储在一个独立的字典中，以后会定时遍历这个字典来删除过期的 key。
* redis默认每隔100ms进行一次检查，即每秒进行十次过期扫描。需要说明的是，redis不是每个100ms将所有的key检查一次，而是随机抽取进行检查，过期扫描不会扫描所有过期字典中的 key，而是采用了一种简单的贪心策略。从过期字典中随机选择 20 个 key；删除这 20 个 key 中已过期的 key；如果过期 key 比例超过 1/4，那就重复步骤 1。
* 同时，为了保证在过期扫描期间不会出现过度循环，导致线程卡死，算法还增加了扫描时间上限，默认不会超过 25ms。
* 如果只采用定期删除策略，会导致很多key到时间没有删除。 因此除了定时遍历外，它还会使用惰性删除策略来删除过期的 key。也就是说在你获取某个key的时候，redis会检查一下，这个key如果设置了过期时间那么是否过期了？如果过期了此时就会删除。
* 如果定期删除没删除key，然后你也没即时去请求key，也就是说惰性删除也没生效。这样，redis的内存会越来越高。为了应对这种情况，redis支持设置内存淘汰机制。

## 3. 缓存更新：立即更新（双写） ##

一致性问题是分布式常见问题，还可以再分为最终一致性和强一致性。数据库和缓存双写，必然不满足强一致性。我们所能做的只是保证最终一致性，需要注意的是，其实从根本上来说，我们只能说降低不一致发生的概率，无法完全避免。因此，有强一致性要求的数据，不能放入缓存。

* 立即更新（双写）：数据更新时立即更新缓存，不过这也会带来更多系统开销和事务一致性问题。

双写的一般实践方式是先更新数据库，再删相应缓存。此外，因为可能存在删除缓存失败的问题，提供一个补偿措施即可，例如设置失效时间等或者使用消息队列等。

## 4. 缓存高可用：分布式缓存 ##

分布式缓存指缓存部署在多个服务器组成的集群中，以集群方式提供服务，其架构方式有两种，一种是以JBossCache为代表的需要更新同步的分布式缓存，一种是以Memcached为代表的不互相通信的分布式缓存。

* JBossCache模式：集群中所有节点保存相同的缓存数据，当某个节点有缓存更新时，会通知其他节点更新缓存或清除缓存数据。这种方法存在的问题是缓存数据量受限于单台节点的内存空间，而且当集群规模大时，同步代价惊人。
* Memcached模式：集群中各个节点互不通信，应用程序通过一致性Hash等路由算法选择访问哪台缓存服务器节点获取数据。这种方式具有很好的可伸缩性。

Memcached模式下路由算法的选择是一个难题。和所有服务器都部署相同应用的应用服务器集群不同，Memcached模式分布式缓存服务器集群中不同服务器中缓存的数据各不相同，缓存访问请求不可以在缓存服务器集群中的任意一台处理，必须先找到缓存中有需要数据的服务，然后才能访问。这个特点会严重制约分布式缓存集群的伸缩性设计，因为新上线的缓存服务器没有缓存任何数据，而已下线的缓存服务器还缓存着网站的许多热点数据。

* 余数Hash（服务器数目除以缓存数据KEY的Hash值，余数作为索引）是最简单的路由算法，但是当缓存集群需要扩容时，该算法将导致集群规模越大缓存命中率下降越厉害。
* 一致性Hash算法：通过一个叫做一致性Hash环的数据结构实现KEY到缓存服务器的Hash映射。

一致性Hash算法具体算法过程：先构造一个长度为0-2的32次方的整数环（这个环被称作一致性Hash环），根据节点名称的Hash值（其分布范围为0-2的32次方）将缓存服务器节点放置在这个Hash环上，然后根据需要缓存的数据的Key值计算得到其Hash值（其分布范围同样为0-2的32次方），然后在Hash环上顺时针查找距离这个Key的Hash值最近的缓存服务器节点，完成key到服务器的Hash映射查找。当缓存服务器需要扩容的时候，只需要将新加入的节点名称的hash值放入一致性hash环中，由于key是顺顺时针查找距离其最近的节点，因此新加入的节点只影响整个环中的一小段。可以发现，随着集群规模增大，继续命中原有缓存数据等概率也逐渐增大。这样就能保证大部分被缓存的数据还可以继续命中，虽然有小部分数据缓存在服务器中不能被读到，但是这个比例足够小，通过方位数据库获取也不会对数据库造成致命的负载压力。

一致性Hash算法等具体实现：一般采用二叉查找树实现，Hash查找过程实际上是在二叉查找树种查找不小于查找树等最小值。当然这个二叉树等最右边叶子节点和最左边的叶子节点项连接构成环。

解决一致性Hash算法带来的负载不均衡问题：增加一层虚拟层，将每台物理缓存服务器虚拟为一组虚拟节点，将虚拟节点的Hash值放在Hash环上。这样，根据key值在环上先找到虚拟节点，再得到物理服务器信息。

jdk实现，hashmap实现，数组+单向链表。hashset本质上也是用hashmap实现的。。。。

## 5. 缓存穿透 ##

* 缓存穿透：不恰当业务或恶意攻击导致持续高并发请求某个不存在数据，若缓存未保存该数据，则所有请求打到数据库上，此时缓存被穿透访问。

解决方案有很多，以下提供一些思路: 

* 提供一个能迅速判断请求是否有效的拦截机制，比如，利用布隆过滤器，内部维护一系列合法有效的key。迅速判断出，请求所携带的Key是否合法有效。如果不合法，则直接返回。将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被这个bitmap拦截掉，从而避免了对底层存储系统的查询压力。
* 一个简单的对策是将不存在的数据也缓存起来（value值为null）。即当我们从数据库找不到的时候，我们也将这个空对象设置到缓存里边去。下次再请求的时候，就可以从缓存里边获取了。这种情况我们一般会将空对象设置一个较短的过期时间。
* 利用互斥锁，缓存失效的时候，先去获得锁，得到锁了，再去请求数据库。没得到锁，则休眠一段时间重试
* 采用异步更新策略，无论key是否取到值，都直接返回。value值中维护一个缓存失效时间，缓存如果过期，异步起一个线程去读数据库，更新缓存。需要做缓存预热(项目启动前，先加载缓存)操作。

## 6. 缓存雪崩 ##

* 缓存雪崩：缓存雪崩，即缓存同一时间大面积的失效，这个时候又来了一波请求，结果请求都打到数据库上，从而导致数据库连接异常。

缓存不可用的场景有很多，比如缓存挂了，或者由于缓存数据设置相同的过期时间致使某段时间内缓存大量失效。

对于“对缓存数据设置相同的过期时间，导致某段时间内缓存失效，请求全部走数据库。”这种情况，非常好解决：

* 给缓存的失效时间，加上一个随机值，避免集体失效。
* 使用互斥锁，但是该方案吞吐量明显下降了。

对于“Redis挂掉了，请求全部走数据库”这种情况，我们可以有以下的思路：

* 事前：实现缓存高可用，尽量避免缓存挂掉。比如Redis的高可用(主从架构+Sentinel 或者Redis Cluster)。
* 事中：万一Redis真的挂了，我们可以设置本地缓存(ehcache)+限流(hystrix)，尽量避免我们的数据库被干掉(起码能保证我们的服务还是能正常工作的)
* 事后：redis持久化，重启后自动从磁盘上加载数据，快速恢复缓存数据。

## 6. 缓存预热 ##

热点数据是根据缓存算法不断筛选出来的，一般这个过程达到基本稳定会花费一定时间，并且期间会有一定的系统负载。所以新启动的缓存需要进行预热。