# 架构之路(06)——会话保持 #

应用服务器等高可用架构设计主要基于服务无状态这一特性，但是事实是业务总是有状态的。Web应用一般使用会话解决这个问题，将多次请求使用的上下文对象称作会话（Session）。当然也可以使用其它技术手段，解决业务状态问题，最终实现无状态的服务。

## 0. 会话 ##

HTTP是一种无状态（stateless）协议，即它并不在当前的请求中记录下任何信息来影响后面的请求。但大多数应用程序都需要一些来回的信息交互，如果在每次交互都需要验证用户ID和口令或者重新输入查询条件就太麻烦了。为了解决这些限制，在浏览器和服务器间采用了各种技术，通过在服务器端维持会话，以保持数据信息的持续交互。在客户端，通常使用cookie、url重写、表单隐藏字段等方式；在服务端，需要实现用户的会话管理。

传统会话Session的实现通常分为两部分：（1）通过Cookie（最常见，也有用请求参数等）将SessionID在浏览器端和后端进行传递；（2）后端通过SessionID去存储中检索数据。

session的集群管理，有以下几种手段。

## 1. 集群的session管理 ##

***1.1 session复制***

集群中所有节点保存相同的session数据，节点之间开启session对象同步功能。这种方法存在的问题是session数据量受限于单台节点的内存空间，而且当集群规模大时，同步代价惊人。

***1.2 session绑定***

session绑定可以利用负载均衡的源地址hash算法实现，负载均衡服务器总是将来源于同一IP的请求分发到同一台真实服务器上。该方法又被称为会话粘滞，这种方式不满足高可用要求。

***1.3 利用cookie记录session***

将session记录在客户端，例如通过cookie方式。这种方式对数据大小有限制，每次传递cookie影响性能，且依赖客户端开启cookie机制，但是实际上很多网站都会采用该种方式。

***1.4 session服务器***

采用专用的session服务器，将应用服务器的状态分离。session服务器可以利用分布式缓存、数据库等技术实现，使其符合session等存储和访问要求。

## 2. 负载均衡与会话保持 ##

前面讨论过负载均衡器，实际上，当负载均衡器接收到一个新的连接时，它的处理方式有两种，进行负载均衡或者做会话保持处理。会话保持与负载均衡是背道而驰的，负载均衡专注于把请求发送到负载最小的服务器上，而会话保持技术则专注于将请求发送到之前提供服务的同一台服务器上。为了能够达到最好的可扩展性和响应时间，我们需要在满足应用需求的前提下尽可能少地采用会话保持技术，以便最大程度的进行负载均衡。

会话保持技术一般大致分为两类：

* 根据TCP SYN数据包的信息来实现会话保持。（为什么是TCP？TCP是端到端的最下面一层）
* 根据用户请求的应用层信息来做会话保持。

根据TCP SYN数据包的信息实现会话保持的技术就是基于源IP地址来实现的，这是确认一个用户的关键，我们称之为基于源IP地址的会话保持方法。基于源IP地址的会话保持也有几种不同的方式，源IP和VIP模式（三层），源IP-VIP-端口模式（四层），端口分组（将互相关联的应用分成一组），在线连接（保证多个连接，比如FTP的数据连接和控制连接都能被转发到相同的服务器上）。

为了检查应用层数据，负载均衡器必须在收到应用层的请求信息之后，才能把这个TCP连接转发到一台服务器，这就是延迟绑定，也就是指推迟将一个TCP连接绑定到一台服务器，直到收到应用层信息的过程。

典型地，负载均衡器的会话保持策略最常见的是4层会话保持和7层会话保持。例如，F5一般支持4层和7层，HA支持7层。

***2.1 基于源IP地址和端口的四层会话保持技术***

当接收到一个TCP SYN数据包后，负载均衡器会在其会话表中查询是否有这个源IP地址的会话纪录。如果没有找到，负载均衡器就认为这是一个新用户的请求，根据负载均衡算法选择一台合适的服务器，并转发此TCP SYN数据包，同时在会话表中增加一条纪录。如果在会话表中存在这个源IP地址的纪录，负载均衡器将会把这个TCP SYN请求包转发到之前处理请求的同一台服务器上，不再通过负载均衡算法选择服务器。当接收到一个TCP FIN或RESET数据包，负载均衡器将中止这个会话，但是在会话表中会继续保留这条纪录，以记住这个连接的源IP地址，和处理这个连接的服务器的地址。

由于负载均衡器并不理解应用层协议，它不知道应用交易何时开始和结束，以便继续或中止会话保持处理。因此，在进行会话保持时，负载均衡器会为会话表中每一条记录都启动一个计时器，计时器从用户最后一次活动的连接结束时开始计时。这个计时器也称作会话保持计时器，主要记录连接空闲的时长。在计时器超时之前如果用户没有新的连接请求，负载均衡器就会把这个用户相应的会话保持记录删除。如果在计时器超时之前收到了用户新的连接请求，负载均衡器会重置计时器，并在用户最后一次活动连接结束时重新启动。

***2.2 延迟绑定的七层会话保持技术***

以WEB应用为例，HTTP请求中包含了URL和Cookies，负载均衡器可以根据这些信息选择更合适的服务器。为了检查应用层数据，负载均衡器必须在收到应用层的请求信息之后，才能把这个TCP连接转发到一台服务器，这就是延迟绑定，也就是指推迟将一个TCP连接绑定到一台服务器，直到收到应用层信息的过程。为了接收到应用层请求，负载均衡器需要代替服务器与客户端建立TCP连接。负载均衡器必须自己给客户端回应SYN ACK数据包。在这个过程中，负载均衡器并不知道服务器会用什么序列号，必须自己生成序列号。一旦收到HTTP请求，负载均衡器选择合适服务器，与服务器建立连接，并将HTTP请求发送给这台服务器。服务器生成的初始序列号可能与负载均衡器跟客户端建立连接的初始序列号不一样。因此，负载均衡器必须转换所有的服务器回应数据包中的序列号以便与客户端连接的序列号保持一致。同样，由于客户端回应中包含一个应答序列号号，负载均衡器同样需要转换。由于负载均衡器必须进行额外的序列号转换的工作，因此延迟绑定会影响负载均衡器的性能。

七层会话保持可以基于cookie实现。关于Cookie的属性和格式，请参考Simon St.Laurent著McGraw-Hill出版的《Cookies》一书。常用的Cookie交换有三种不同的方式：Cookie-Read，Cookie-Insert，和Cookie-Rewrite。每种方式对负载均衡器的性能和服务器端应用的设计都会产生不同的影响。

现在，我们来讨论如何才能让Cookie-Read模式正常工作。首先，负载均衡器必须支持Cookie交换。更重要的是，服务器上的Web应用必须设置一个“Server=服务器ID”的Cookie。服务器必须知道它自己的ID是什么，而负载均衡器必须知道如何将服务器ID唯一的对应到这台服务器。Cookie-Read方法的缺点是需要服务器自己产生Cookie，产生Cookie并不困难，但是需要应用开发商的配合。服务器的应用系统需要知道在负载均衡器中定义的服务器的ID。当增加一台新的服务器或者改变某台服务器的配置时，网络管理员必须设置或修改服务器的ID，以便与负载均衡器的配置保持一致。

当采用Cookie-Insert模式的时候，应用系统不需要做任何改变。第一个请求因为没有Cookie，所以被负载均衡到S1。当服务器回应时，负载均衡器查看服务器的回应包，并插入一个包含服务器ID信息的Cookie，比如“server=1”。后续的HTTP请求都将包含“Server=1”的Cookie，如果负载均衡器在把请求转发给服务器之前时没有将Cookie删除，服务器会看到这个Cookie。通常负载均衡器会保留数据包中的Cookie，因为服务器应用并不关心Cookie。采用Cookie-Insert模式的优点是对于服务器应用来说是完全透明的。无论是增加还是删除服务器，或者变更负载均衡器的配置，网络管理员都不需要担心去更新服务器的配置。采用Cookie-Insert方法的缺点是负载均衡器的性能压力和潜在的数据延迟。

Cookie-Read不像Cookie-Insert那样需要负载均衡器做很多工作，但是它要求服务器修改应用程序的配置，而Cookie-Insert不需要服务器做任何改变，Cookie-Rewrite则取二者之所长。 采用Cookie-Insert最大问题是在Cookie插入的过程中需要复杂的内存管理机制，并且插入Cookie之后如果数据包大小超过网络允许的最大值还需要分割数据包。如果服务器回应的数据包中预留Cookie的位置，而负载均衡器只需要给这个Cookie设定一个正确的值将会怎么样呢？在Cookie-Rewrite方法中，需要修改服务器应用，生成一个Cookie并赋予一个缺省的数值，如应用系统插入一个Cookie“server=XXX”。应用系统不需要关心服务器ID，都设置成“XXX”。当负载均衡器接收到服务器的HTTP回应数据包后，查找Cookie并设置为正确的服务器的ID号码。因为负载均衡器没有在数据包中增加任何字节，这将保证数据包长度不变，从而排除了分割数据包的可能性。这种方法的优点是没有数据包分割所带来的巨大的性能损耗，也不需要复杂的内存管理机制。这种方法要比Cookie-Read好，尽管都需要服务器端生成Cookie，但Cookie Rewirte只需要生成一个赋有缺省值的Cookie即可，应用系统不需要关心服务器的ID。这样也减轻了管理员的负担，不必担心增加或减少服务器时修改负载均衡器配置的问题。

在处理HTTPS流量时，负载均衡器无法利用Cookie来实现会话保持或者解决高速代理服务器的问题。SSL运行在TCP协议之上，是一个有状态的协议，它使用会话标识符（会话ID）来唯一标识一个会话，因此负载均衡器可以采用SSL会话ID来进行会话保持。目前存在几个不同版本的SSL协议，本章主要讨论SSL协议V3.0。在V3.0版本之前，负载均衡器是不能识别SSL会话ID的，因为会话ID也是被加密的。V3.0以后的版本，SSL会话ID采用明文传输。有一点需要注意，负载均衡器是不能够读取任何加密的信息的，只有服务器才能。 客户端与服务器之间采用HTTPS进行传输的流程如下，首先，客户端建立一个TCP连接并发送一个客户端问候消息，服务器回应一个服务器问候消息，这个过程是SSL握手的一部分。在SSL握手过程中，双方协商加密和解密的相关参数。如欲了解SSL握手的详细过程，可以参考Netscape网站上公布的SSL V3.0的定义。其中一个参数就是在服务器回应问候消息时设置的会话ID，客户端的浏览器把会话ID信息保存在内存中，并在后续连接中继续使用这个会话ID，以避免重新协商相关参数。此外，浏览器也可以利用这个会话ID同时建立多个TCP连接。再回到HTTPS流量的负载均衡上来，当客户端第一次发起SSL连接时，服务器会产生SSL会话ID并将其作为服务器问候消息的一部分返回给客户端。当负载均衡器收到从S1发出的服务器问候消息时，就把会话ID提取出来，在内存建立一张对应表，把这个会话ID和S1关联起来，然后把这个问候消息转发给客户端。一旦接收到这个问候消息，客户端浏览器就把会话ID保存到内存中。当浏览器在同一个应用交易中发起新的TCP连接时，它会继续使用这个会话ID。这次，另外一台代理服务器处理这个新的连接，负载均衡器通过延迟绑定提取会话ID信息。负载均衡器在对应表中查找，找到会话ID所对应的服务器S1，并这个连接转发给S1以保证会话保持。采用这种方法时，负载均衡器不再根据源地址来标识用户，因此高速代理服务器负载均衡的问题也相应得到解决。所有没有会话ID或会话ID不在负载均衡器的对应表中的连接都会被负载均衡到一台可用的服务器上。一旦从服务器端接收到SSL会话ID，浏览器在多长时间内会复用这个会话ID还不确定，这段时间不一定和应用交易的时间相吻合。当用户在网上购物时，一个SSL会话的时间可能会很短，但是对于银行或证券等在线交易的会话时间可能会比较长，因为用户可能不会关闭浏览窗口，使其一直处于打开状态。Web服务器的应用系统可能会采取超时机制，强制让用户重新登录和认证。问题是，如果浏览器在应用交易过程中重新协商一个SSL会话ID，那这种会话保持方法就会失效。避免这个问题的方法就是使用基于源地址的会话保持方法作为备份，但这就会带来高速代理服务器的问题，也可以采用SSL加速的技术来解决这个问题。

## 3. ##

## 参考 ##

《负载均衡之TCP会话保持（一）》，vicent0.0，https://zhuanlan.zhihu.com/p/32943807

