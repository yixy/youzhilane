# OS(02)-进程与线程 #

## 1. 进程模型及其意义 ##

进程（process）是对正在运行程序的一个抽象。一个进程是某个程序的一个实例。一个程序如果被执行了两遍，则算作两个进程。

某个瞬间，一个CPU只能运行一个进程。在任何多道程序设计系统中，CPU总是由一个进程快速切换至另一个进程，以此来实现并发。所以说，实际上进程的概念其实也是对CPU的一种抽象。

* concurrent：并发，多个事件在同一时间间隔内发生。
* parallel：并行，多个事件在同一时刻发生。

人们很难对CPU的多个并发活动切换进行跟踪，因此操作系统设计者发展了用于描述这一概念的模型（顺序进程集），使其更容易理解和处理。

## 2. 进程的状态 ##

进程有四种状态。

* 运行态：该时刻进程实际占用CPU。
* 就绪态：可运行，但是当前没有可用CPU。可能是刚由阻塞恢复，或者由内核调度CPU被占用而不能运行。
* 阻塞态：正在执行的进程在逻辑上不能继续运行（等待某个事件发生而无法执行），便放弃CPU而处于阻塞状态。引起进程阻塞的事件可有多种，例如，等待I/O完成、申请缓冲区不能满足、等待信件(信号)等。
* 终止态：进程运行完毕，出错退出，或被其它进程杀死。

Linux的进程状态在fs/proc/array.c 文件里定义：

```
/*
* The task state array is a strange "bitmap" of
* reasons to sleep. Thus "running" is zero, and
* you can test for combinations of others with
* simple bit tests.
*/
static const char * const task_state_array[] = {
"R (running)",      /* 0 */正在运行 或 可运行(在运行队列排队中)
"S (sleeping)",     /* 1 */可中断睡眠(休眠中，受阻，在等待某个条件的形成或接收到信号)
"D (disk sleep)",   /* 2 */不可中断睡眠(通常是在IO操作)，收到信号不唤醒和不可运行，进程必须等待直到有中断发生
"T (stopped)",      /* 4 */暂停状态，进程收到 SIGSTOP, SIGSTP, SIGTIN, SIGTOU 信号后停止运行
"t (tracing stop)", /* 8 */跟踪状态，指的是进程暂停下来，等待跟踪它的进程对它进行操作
"X (dead)",         /* 16 */退出状态，进程即将被销毁
"Z (zombie)",       /* 32 */退出状态，进程成为僵尸进程
};
```

> “运行态”和“就绪态”两种状态在linux下统一为 TASK_RUNNING（R状态）状态。同一时刻可能有多个进程处于 TASK_RUNNING状态，这些进程的task_struct结构（进程控制块）被放入对应CPU的可执行队列中（一个进程最多只能出现在一个CPU的可执行队列中）。进程调度器的任务就是从各个CPU的可执行队列中分别选择一个进程在该CPU上运行。
> “阻塞态”在Linux下被分为TASK_INTERRUPTIBLE（interruptable sleep，S状态 for sleeping）和TASK_UNINTERRUPTIBLE（uninterruptable sleep，D状态for DiskSleeping）。进程列表中的绝大多数进程都处于TASK_INTERRUPTIBLE状态（除非机器的负载很高）。处于TASK_INTERRUPTIBLE状态的进程因为等待某事件的发生（比如等待socket连接、等待信号量），而被挂起。这些进程的task_struct结构被放入对应事件的等待队列中。当这些事件发生时（由外部中断触发、或由其他进程触发），对应的等待队列中的一个或多个进程将被唤醒。TASK_UNINTERRUPTIBLE与TASK_INTERRUPTIBLE状态类似，进程处于睡眠状态，但是此刻进程是不可中断的，例如对某些硬件设备进行操作时刻（等待磁盘Io,等待网络io等等）。不可中断，指的并不是CPU不响应外部硬件的中断，而是指进程不响应异步信号。绝大多数情况下，进程处在睡眠状态时，总是应该能够响应异步信号的。而TASK_UNINTERRUPTIBLE状态存在的意义就在于，内核的某些处理流程是不能被打断的。如果响应异步信号，程序的执行流程中就会被插入一段用于处理异步信号的流程（这个插入的流程可能只存在于内核态，也可能延伸到用户态），于是原有的流程就被中断了。在进程对某些硬件进行操作时（比如进程调用read系统调用对某个设备文件进行读操作，而read系统调用最终执行到对应设备驱动的代码，并与对应的物理设备进行交互），可能需要使用TASK_UNINTERRUPTIBLE状态对进程进行保护，以避免进程与设备交互的过程被打断，造成设备陷入不可控的状态。这种情况下的TASK_UNINTERRUPTIBLE状态总是非常短暂的，通过ps命令基本上不可能捕捉到。（如果进程在top和ps看到长期处于D状态，那么可能进程在等待IO时出现了问题导致进程一直等待不到IO资源 此时如果要处理掉这个D进程，那么只能重启整个系统才会恢复。因为此时整个进程无法被kill 掉。）
> “终止态”对应Linux的dead（X）和 zombie（Z）。死亡状态（dead）是内核运行 kernel/exit.c 里的 do_exit() 函数返回的状态，这个状态只是一个返回状态，你不会在任务列表里看到这个状态。当进程退出并且父进程没有（使用wait()系统调用）读取到子进程退出的返回代码时就会产生僵尸进程。僵尸进程会以终止状态保持在进程表中，并且会一直在等待父进程读取退出状态代码。
> Linux定义了两种额外的状态：1）暂停状态（T），可以通过发送 SIGSTOP 信号给进程来暂停进程，这个被暂停的进程可以通过发送 SIGCONT 信号让进程继续运行。2）跟踪状态（t）指当进程正在被跟踪时，它处于 TASK_TRACED 这个特殊的状态。“正在被跟踪”指的是进程暂停下来，等待跟踪它的进程对它进行操作，比如在gdb中对被跟踪的进程下一个断点，进程在断点处停下来的时候就处于 TASK_TRACED 状态。而在其他时候，被跟踪的进程还是处于前面提到的那些状态。

## 3. 进程的实现 ##

* 进程有自己的地址空间，用于存放可执行程序、数据、堆栈。
* 进程除地址空间以外的信息都存放在内核的进程表中，每个进程占用一个表项，包含寄存器（程序计数器和堆栈指针等），打开文件清单，内存分配状况，账号和调度信息，以及其它进程状态转换时必须的信息。

## 4. 线程模型及其意义 ##

**线程与进程的区别在于，线程共享地址空间，另外，线程保有自己的堆栈信息。**

线程模型的意义在于：

* 对于某些应用而言，并发实体共享一个地址空间和所有可用数据的能力是必须的，而多进程模型无法表达。
* 线程比进程更轻量级，它们比进程更容易（即更快）创建，也更容易销毁。在许多系统中，创建一个线程比创建一个进程要快10到100倍。并且线程切换的开销比进程切换的开销更少。
* 对于IO密集型的应用，多线程允许任务彼此重叠执行，从而加快整个应用的执行速度。
* 在多CPU系统中，真正的并行有了实现的可能。

不支持多线程的操作系统，其进程可以看作是只有一个线程的进程。