# OS笔记(3)——进程间通信 #

进程间通信（IPC，Inter Process Communication）的问题和解决方法，同样适用于线程，下面不再单独讨论线程。

***但是需要注意的是基于共享变量的通信方式（忙等待、信号量等）通常是应用在线程间通信的（因为进程并不共享地址空间），进程间通信一般使用消息传递机制。***

## 1. IPC面临的问题 ##

IPC需要解决以下三个问题：

* 通信：一个进程如何向其它进程传递消息。
* 互斥：确保多个进程在关键活动中互斥（不会出现交叉执行）。
* 同步：确保多个进程执行保持一定的顺序（保证某种事件的顺序发生或不发生）。

一些概念：

* 竞争条件（race condition）：多个进程读写某些共享数据，而最后的结果取决于进程运行的精确时序，这称为竞争条件。
* 临界区（critical region/section）：对共享内存进行访问的程序片段被称为临界区。
* 原子操作：指一组相关联的操作要么都不间断地执行，要么都不执行。

## 2. 忙等待的互斥 ##

本节讨论几种实现互斥的方案。这些方法本质上是这样的：当一个进程想进入临界区，先检查是否允许进入，若不允许，则该进程将原地等待，直到允许为止。

**屏蔽中断**

在单处理器系统中，最简单的方法是使每个进程刚刚进入临界区后立即屏蔽所有其它中断，并在离开之前再打开中断。这样做的原因是CPU只有发生时钟中断或其它中断时才会进行进程切换。

**严格轮转法**

采用软件方式，使进程严格地轮流进入它们的临界区。常用的方式是采用忙等待一直扫描，直到检测到预期的值。

```
//进程0
for{
  for turn!=0{
    //临界区
  }
  turn=1
}

//进程1
for{
  for turn!=1{
    //临界区
  }
  turn=0
}
```

**Peterson算法**

通过将锁和警告变量的思想相结合，提出的一个不需要严格轮转的软件互斥算法。

```
void enter_region(int process){ //进程号，0或1
  int other = 1- process //其它进程号
  interest[process]=true
  turn=process
  for turn==process && interest[other]==true {}
}

void leave_region(int process){
  interest[process]=false
}
```

**TSL或XCHG指令**

通过类似原子指令写锁变量实现互斥。这些指令的原子操作是由锁住存储总线保证的，所以对多处理器也能很好的工作。

## 3. 信号量 ##

忙等待会浪费CPU时间，另外，容易引起死锁（例如优先级反转问题）。可以使用信号量机制，让进程在无法进入临界区时阻塞，而不是忙等待。

* 信号量：一个整型变量，取值可以为0或正整数。
* 信号量的down操作：检查信号量的值是否大于0，若大于0则将其值减1；若值为0，则进程进入阻塞状态，此时down操作未完成。注意，检查数值，修改数值（或发生的阻塞）均为不可分割的原子操作。
* 信号量的up操作：使信号量的值加1，唤醒一个阻塞在down操作的进程（如果存在的话），并允许该进程完成其down操作。注意，信号量的增1和唤醒一个进程同样是不可分割的原子操作。

通常，信号量操作中的原子性也通过屏蔽中断实现。

**利用信号量实现互斥**

```
s=1//初始化信号量
P1(){
  P(s)
  //临界区
  V(s)
}
P2(){
  P(s)
  //临界区
  V(s)
}
```

**利用信号量实现同步**
```
//先执行x，后执行y
s=0//初始化信号量
P1(){
  x
  V(s)
}
P2(){
  P(s)
  y
}
```

## 4. 管程 ##

使用信号量进行编程较为麻烦，一处很小的编码错误可能导致很严重的问题。为了更易于编写更正确的程序，很多编程语言提出了管程的概念。

* 管程（monitor）：管程是一个编程语言概念，编译器必须识别管程并用某种方式对其互斥做出安排。一个管程是一个由过程、变量、数据结构等组成的一个集合，它们组成一个特殊的模块或软件包。任一时刻，管程中只能有一个活跃进程。通过临界区互斥的自动化，管程比信号量更容易保证并行编程的正确性。

## 5. 消息传递 ##

忙等待和信号量机制实际上是借助了共享变量实现的。多个线程访问一个信号量是没问题的，但是对于进程来说就不是这样了。通常可以采用两个方式解决这个问题，要么将信号量放入内核，要么使用操作系统提供的进程共享空间机制（例如管道），如果操作系统不提供类似机制，则还可以自行使用文件进行。

实际上，进程间通信通常只采用消息传递的方式，例如使用TCP通信。

## 6. 屏障：进程组的同步机制 ##

在有些应用中划分了若干阶段，并且规定，除非所有进程都就绪准备着手下一阶段，否则任何进程都不能进入下一个阶段。可以在每个阶段的结尾安置屏障（barrier）来实现这种行为。当一个进程到达屏障时，它就被屏障阻拦，直到所有进程都到达该屏障为止。

## 7. 参考 ##

《现代操作系统》，Tanenbaum，P79，忙等待和信号量在分布式系统面临的问题。
