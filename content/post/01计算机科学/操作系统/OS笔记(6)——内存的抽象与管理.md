# OS笔记(7)——内存的抽象与管理 #

由于register和cache的管理由硬件完成，所以我们由内存管理开始我们对操作系统存储管理的介绍。

## 1. 无内存抽象 ##

最早的内存管理是直面物理内存的，即没有内存抽象。此时的内存组织方式出现过以下几种。

* “用户程序+RAM”：用于大型机和小型机。
* “ROM+用户程序”：用于掌上设备或嵌入式设备。
* “ROM+用户程序+RAM”：用于早期PC。

直接使用物理内存面临两个问题，第一，用户可以寻址内存的每个字节，导致系统可以很容易地被（故意或偶然地）破坏，（除非使用特殊的硬件保护，如IBM360的锁键模式）；第二，系统想要并发运行多道程序是很困难的。

## 2. 内存抽象：虚拟地址空间 ##

用户程序在运行时其实不希望介入到复杂的存储器管理过程中，作为普通的程序，它需要的是一个简单的执行环境，有一个单一的地址空间、有自己的CPU，好像整个程序占有整个计算机而不用关心其它的程序（当然程序间通信的部分除外，因为这是程序主动要求跟其它程序通信和联系）。进程模型是对CPU的一个抽象，而地址空间则为程序创造了一种抽象的内存。

* 虚拟地址空间：虚拟地址空间是一个进程可用于寻址内存的一套地址集合。每个进程都有一个自己的虚拟地址空间，并且这个虚拟地址空间独立于其它进程的地址空间（除了在一些特殊情况下进程需要共享它们的地址空间外）。

进程的虚拟地址并不是直接被送到内存总线上，而是被送到内存管理单元（MMU），MMU把虚拟地址映射为物理内存地址。

## 3. 内存地址重定位 ##

可以采用重定位技术以支持多道程序在系统中运行。其中，动态重定位技术还提供了地址保护机制。

* 静态重定位：指在程序执行之前，在装载过程中完成程序地址重定位。在程序装载到内存时，系统为每个程序地址加上一个偏移量常数。
* 动态重定位：指在程序运行中进行地址重定位。当一个进程运行时，程序在内存中的起始物理位置读取到基址寄存器中，程序的长度读取到界限寄存器中。进程每次访问内存时，CPU硬件会在把地址发送到内存总线前，自动把基址值加到进程发出的地址上，同时检查程序提供的地址是否合法（是否超过界限值）。

静态重定位方式会减慢装载速度，并且没有地址保护机制。动态重定位具有地址保护机制，但是每次访问内存时需要进行加法和比较运算（加法在不使用特殊电路时会很慢），导致重定位效率低下。

## 4. 交换（swap）技术 ##

如果计算机物理内存足够大，可以保存所有进程，那么使用地址空间抽象并运用内存地址重定位技术似乎已经可以解决所有问题了。但实际上，所有进程所需的内存数量总是远远超出存储器能够支持的范围的。可以使用交换技术解决内存超载的问题。

* 交换（swapping）技术：一个进程在内存中运行一段时间后，再将该进程保存到磁盘。这样，不在运行的进程就不会占用内存了。

交换会在内存中产生很多空洞（hole）区域。可以采用内存紧缩的技术解决这种碎片化的空洞区，但是这个操作会耗费大量的CPU时间，所以通常情况下是不会进行的。

* 内存紧缩（memory compaction）：通过把所有的进程尽可能向某个方向移动，可能将小的空洞合成一大块，该技术被称为内存紧缩。

许多程序设计语言允许从堆中动态地分配内存，那么当进程空间试图增大时，交换技术可能会面临问题。为增长预留空间是一个解决方案。

## 5. 虚拟内存技术：分页 ##

前面说过，重定位的效率不高，实际上该技术在内存管理上已经不太常用了。而交换技术也面临着进程空间膨胀的难题。虚拟内存技术是另一种可以解决内存超载问题的技术。该策略甚至能使程序在只有一部分被调入内存的情况下运行。

* 虚拟内存（virtual memory）技术：将进程的虚拟地址空间分割成多个块，每块被称作一个页面（page）。每一页有连续的地址范围。这些页面被映射到物理内存（在物理内存中对应的单元称为页框page frame），但并不是所有的页面都必须在内存中才能运行程序。当进程引用到一部分在物理内存的页面时，由硬件立刻执行必要的映射。当进程引用到一部分不再物理内存的页面时，指令执行失败，进程陷入缺页中断，由OS负责将缺失的部分装入物理内存并重新执行失败的指令。内存和磁盘之间的交换总是以正规页面为单元进行的。

页面的大小一般从512B到64KB。

* 页表：页表是一个数据结构，其目的是把page映射为page frame。从数学角度说，页表是一个函数，它的参数是虚拟页号，结果是page frame。注意，每个进程都拥有自己的页表。

![页表](http://sweeat.me/pagetable.png)

上图展示了虚拟地址（虚拟页号+页内偏移量）通过页表转换为物理地址（页框号+页内偏移量）的过程。

在分页式系统中，有两个问题需要考虑：虚拟地址到物理地址的映射必须非常快；需要考虑应对虚拟地址空间很大的情况。

**5.1 加速分页过程：TLB**

通常，页表被设计在内存中，每次虚拟地址到物理地址的映射都必须访问内存，这样会导致性能低下。考虑将页表使用一组硬件快速寄存器实现是一种思路，但是考虑到昂贵的代价显然不可能将每个进程的页表都用这种方式实现。一个显而易见的方案是，使用一组硬件寄存器组成单一的页表，当启动一个进程时，操作系统将该进程在内存中的页表副本载入寄存器中。这样，该进程的地址映射过程中不再需要访问内存中的页表了，但是这样又增加了进程间切换时的开销。目前，一种常见的解决方案是使用TLB。

* TLB（Translation Lookaside Buffer，转换检测缓冲区）：“大多数程序总是对少量的页面进行多次访问”，基于这样的思想，在MMU中设置一个小型的硬件设备，它包含少量的表项，该设备就是TLB。地址映射首先在TLB中由硬件进行转换，如果TLB中匹配不到才会到去访问内存表项。

注意，最初，对TLB的管理和TLB失效处理都完全由MMU硬件来实现，只有在内存中没有找到某个页面时，才会陷入到操作系统中。后来，很多机器的几乎所有的页面管理都在软件中实现了。这些机器上，TLB表项被显示地装载。当发生TLB访问失效的时候不再是MMU到页表中查找并取出数据，而是生成一个TLB失效并将问题提交给操作系统解决。事实证明，如果TLB大（比如64个表项）到可以减少失效率，TLB的软件管理也能够变得足够有效。

**5.2 处理巨大的虚拟地址空间：多级页表与倒排页表**

以32位虚地址为例，后12位为偏移量，则页面大小为4KB，页面数量为2^20。

采用“多级页表”的原因是避免把全部页表一直保存在内存中，那些从不需要的页表项将被存储在磁盘。一般，页表级数不超过4级。

当虚拟地址空间是2^64字节时（64位计算机），假设页面大小是4KB，需要有2^52个表项。即使采用了多级页表，存储在磁盘上的表项数据所占用的空间也是巨额的。此时，解决方案之一是使用倒排页表（invertered page table）。在这种设计之中，实际内存里每一个页框有一个表项，而不是每一个虚拟页面有一个表项。

![倒排页表](http://sweeat.me/inverted_page_table.png)

采用倒排页表能够显著减少页表项，但是它使得从虚拟地址到物理地址的转换变得更困难，每次必须遍历整个页表来查找，而不是使用虚拟页号做索引。使用TLB能够缓解这个问题。但是当TLB失效时，还需要进行优化，此时可以使用虚拟地址来散列（确保不同散列值的数量与页表项数量相同，相同的散列值的表项使用链表相链）。

![倒排hash页表](http://sweeat.me/inverted_hash_page_table.png)

## 6. 多维度的虚拟内存技术：分段 ##

到目前为止我们讨论的虚拟内存都是一维的，虚拟地址从0到最大地址，一个地址接着另一个地址。但是，对许多问题来说，有两个或多个独立的地址空间可能比只有一个要好得多。比如，一个编译器在编译过程中会建立许多表，其中可能包括1）源程序；2）符号表，包括变量名及其属性；3）包含常量的表；4）语法分析树；5）编译器内部过程调用使用的堆栈。其中，前4个表随编译的进行不断的增长，最后一个表则在编译过程中以一种不可预计的方式增长和缩小。想象一下，在一维存储器中，这5个表只能被分配到虚拟地址空间中连续的块中。这样带来的问题是，要么空间存在大量浪费（因为需要预留增长空间），要么用户程序需要手工对内存交换进行管理。

一个直观并且通用的方法是在机器上提供多个互相独立的称为段（segment）的地址空间。每个段由一个从0到最大的线性地址序列构成。各个段的长度可以是0到某个允许的最大值之间的任何一个值。不同的段的长度可以不同，并且通常情况下也都不相同。段的长度在运行期间可以动态改变。

需要强调的是，段是一个逻辑实体，程序员知道这一点并把它作为一个逻辑实体来使用。一个段可能包括一个过程、一个数组、一个堆栈、一组数值变量，但一般它不会同时包含多种不同类型的内容。

**段页式存储**

程序按逻辑块分段，段内再分页，内存仍以页为信息传送单位，这样的虚拟存储器被称为段页式虚拟存储器。在段页式虚拟存储器中，每个程序对应一个段表，每段对应一个页表，段的长度必须是页长的整数倍，段的起点必须是某一页的起点。

此时，虚拟地址由三部分组成（段号+段内页号+页内偏移量）。CPU根据虚拟地址访问时，首先根据段号得到段表地址；然后从段表中取出该段的页表起始地址，与虚拟地址中的段内页号合成，得到页表地址；最后从页表中取出实际页框号，与页内偏移量拼接形成实际地址。

## 7. 参考 ##

Berkeley，http://www.cs.virginia.edu/~cs333/notes/virtual_memory4.pdf
