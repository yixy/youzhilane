# 多路查找树——B树与B+树 #

B/B+ 树就是N叉（N-ary）平衡树了，每个结点可以有更多的孩子，新的值可以插在已有的结点里，而不需要改变树的高度，从而大量减少重新平衡和数据迁移的次数，这非常适合做数据库索引这种需要持久化在磁盘，同时需要大量查询和插入操作的应用。

* B树：B-tree（B-tree树即B树，B即Balanced，平衡的意思）

> 有的文章里面出现的B-树，即为B树。因为B树的原英文名称为B-tree，而国内很多人喜欢把B-tree译作B-树，其实，这是个非常不好的直译，很容易让人产生误解。如人们可能会以为B-树是一种树，而B树又是一种一种树。而事实上是，B-tree就是指的B树。

* B+树：B+树是B树的变种树，有n棵子树的结点中含有n个关键字，每个关键字不保存数据，只用来索引，数据都保存在叶子结点。

B+树用在磁盘文件组织、数据索引和数据库索引。数据库索引采用B+树的主要原因是B树在提高了磁盘IO性能的同时并没有解决元素遍历的效率低下的问题。正是为了解决这个问题，B+树应运而生。B+树只要遍历叶子节点就可以实现整棵树的遍历。而且在数据库中基于范围的查询是非常频繁的，而B树不支持这样的操作（或者说效率太低）。

* B/B+树时间复杂度：查找、插入和删除在平均和最坏情况下都是O（log n）
* B/B+树空间复杂度：O(n)，因为有指针（B树还有关键字）

## 1. B树 ##

2-3树是一种特殊的B树。

![2-3树](http://sweeat.me/2-3树.png)

M阶B树的定义：

![B树](http://sweeat.me/B树.png)

* 每一个节点最多有 m 个子节点
* 每一个非叶子节点（除根节点）最少有 ⌈m/2⌉ 个子节点
* 如果根节点不是叶子节点，那么它至少有两个子节点
* 有 k 个子节点的非叶子节点拥有 k − 1 个关键字（即非叶子结点有k个指针和k-1个关键字）
* 所有的叶子节点都在同一层

>m/2的限制一是为了保证存储密度，二是避免树结构退化，保证其在磁盘存储器中的存储优势。正因为 b 树是一个稳定的多叉结构，每一个节点有多个 key 和分支。在磁盘存储器这样的 查找速度慢(硬件条件限制)，以存储块(一个相对较大的块)为单位读取的 硬件结构中，才有了明显的优势。

## 2. B树的查找 ##

![B树查找](http://sweeat.me/B树查找.png)

![B树查找性能](http://sweeat.me/B树查找性能.png)

## 3. B树的插入 ##

![B树插入1](http://sweeat.me/B树插入1.png)
![B树插入2](http://sweeat.me/B树插入2.png)
![B树插入3](http://sweeat.me/B树插入3.png)
![B树插入4](http://sweeat.me/B树插入4.png)

## 4. B+树 ##

M阶B+树是M阶B树的变种树：

![B+树](http://sweeat.me/B+树.jpg)

* B+ 树中的非叶子结点不存储关键字数据，只是存储索引；（B 树中的结点存储数据）
* 通过链表将叶子结点串联在一起，这样可以方便按区间查找；（B树叶子结点没有串联）
* 一般情况，根结点会被存储在内存中，其他结点存储在磁盘中。

不管是内存中的数据，还是磁盘中的数据，操作系统都是按页（一页大小通常是 4KB，这个值可以通过 getconfig PAGE_SIZE 命令查看）来读取的，一次会读一页的数据。如果要读取的数据量超过一页的大小，就会触发多次 IO 操作。所以，我们在选择 m 大小的时候，要尽量让每个结点的大小等于一个页的大小。读取一个结点，只需要一次磁盘 IO 操作。

## 5. B+树插入关键字 ##

在B+树中插入关键字时，需要注意以下几点：

* 插入的操作全部都在叶子结点上进行，且不能破坏关键字自小而大的顺序；
* 由于 B+树中各结点中存储的关键字的个数有明确的范围，做插入操作可能会出现结点中关键字个数超过阶数的情况，此时需要将该结点进行“分裂”；

M阶B+树中做插入关键字的操作，有以下 3 种情况：

1. 若被插入关键字所在的结点，其含有关键字数目小于阶数 M，则直接插入结束
2. 若被插入关键字所在的结点，其含有关键字数目等于阶数 M，则需要将该结点分裂为两个结点，一个结点包含⌊M/2⌋，另一个结点包含⌈M/2⌉。同时，将⌈M/2⌉的关键字上移至其双亲结点。假设其双亲结点中包含的关键字个数小于 M，则插入操作完成。
3. 在第 2 情况中，如果上移操作导致其双亲结点中关键字个数大于 M，则应继续分裂其双亲结点。

注意：如果插入的关键字比当前结点中的最大值还大，破坏了B+树中从根结点到当前结点的所有索引值，此时需要及时修正后，再做其他操作。例如，在图 1 的 B+树种插入关键字 100，由于其值比 97 还大，插入之后，从根结点到该结点经过的所有结点中的所有值都要由 97 改为 100。改完之后再做分裂操作。

## 6. B+树删除关键字 ##

在 B+树中做删除关键字的操作，采取如下的步骤：

* 删除该关键字，如果不破坏 B+树本身的性质，直接完成操作；
* 如果删除操作导致其该结点中最大（或最小）值改变，则应相应改动其父结点中的索引值；
* 在删除关键字后，如果导致其结点中关键字个数不足，有两种方法：一种是向兄弟结点去借，另外一种是同兄弟结点合并。（注意这两种方式有时需要更改其父结点中的索引值。）

## 7. B+树与索引 ##

数据库索引需求：

* 根据某个值查找数据，比如 select * from user where id=1234；
* 根据区间值来查找某些数据，比如 select * from user where id > 1234 and id < 2345。

1. 为什么不使用散列表呢？

虽然散列表时间复杂度是O(1)，但是不支持按照区间快速查找数据。

2. 为什么不使用平衡二叉树呢？

尽管平衡二叉查找树查询的性能也很高，时间复杂度是 O(logn)。而且，对树进行中序遍历，我们还可以得到一个从小到大有序的数据序列，但这仍然不足以支持按照区间快速查找数据。并且，对于大数据量持久化存储，二叉排序树的深度k会很大，每次查询需要进行多次磁盘IO。

二叉查找树，经过改造之后，支持区间查找的功能就实现了。为了让二叉查找树支持按照区间来查找数据，我们可以对它进行这样的改造：树中的结点并不存储数据本身，而是只是作为索引。除此之外，我们把每个叶子结点串在一条链表上，链表中的数据是从小到大有序的。

不管是内存中的数据，还是磁盘中的数据，操作系统都是按页（一页大小通常是 4KB，这个值可以通过 getconfig PAGE_SIZE 命令查看）来读取的，一次会读一页的数据。如果要读取的数据量超过一页的大小，就会触发多次 IO 操作。所以，我们在选择 m 大小的时候，要尽量让每个结点的大小等于一个页的大小。读取一个结点，只需要一次磁盘 IO 操作。

数据的写入过程，会涉及索引的更新，这是索引导致写入变慢的主要原因。