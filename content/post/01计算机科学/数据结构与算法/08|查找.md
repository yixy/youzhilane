# 查找 #

## 1. 什么是查找 ##

* 查找：事先给定一个值，在查找表（同一类型的数据元素构成的集合）中找到其关键字等于给定值的数据元素（一个或多个）。

除了时间复杂度和空间复杂度之外，通常还使用ASL来衡量查找算法的好坏程度。

* 平均查找长度ASL（Average Search Length）：关键字的平均比较次数。

## 2. 静态查找与动态查找 ##

查找的目的：

1. 查询特定数据是否在查找表中
2. 检索查找表中某个特定数据的属性
3. 在查找表中插入一个数据元素
4. 在查找表中删除某个数据元素

* 静态查找（static search）：仅对查找表进行上述的前两种查找操作
* 动态查找（dynamic search）：存在上述的第3种或第4种查找操作

## 3. 查找相关的数据结构对比 ##

1. 线性表：线性表中效率最好的二分查找为O(logn)，但是对动态查找支持不好（要求有序并且是顺序表，插入删除操作需要大量元素移动）

线性表的顺序查找适用场景较广，但是效率相对较低。若是动态查找场景，可以采用链表实现，避免大量元素移动；并且由于线性表中元素无序，所以即使是采用顺序存储，新增时也不会产生大量元素移动。

* 时间复杂度：O(n)
* 空间复杂度：O(1)

线性表的二分查找效率较好，但是适用场景单一（要求有序并且是顺序表），对于动态查找场景（大量插入和删除）需要移动大量元素。

* 时间复杂度：O(logn)
* 空间复杂度：O(1)，非递归实现

线性表分块索引查找性能介于顺序查找和二分查找之间。对于动态查找场景，插入、删除较为容易，无需进行大量元素移动。但需要引入额外的索引存储空间，并对初始索引进行排序计算。

* 时间复杂度：log(n/s) + s，s为每块元素数量
* 空间复杂度：O(n/s)

2. 平衡二叉树（AVL）与红黑树：如果希望拥有与折半查找同样的查找效率O(logn)，并且对频繁的插入删除操作不需要大量元素移动，可以使用AVL或红黑树。

* 二叉排序树：时间复杂度最佳情况是 O(log­n)，而最坏情况是 O(n)。空间复杂度是O(n)，因为有指针。
* AVL：查找、插入和删除在平均和最坏情况下都是O（log n）。空间复杂度是O(n)，因为有指针及平衡因子。
* RBtree：查找、插入和删除在平均和最坏情况下都是O（log n）。空间复杂度是O(n)，因为有指针及颜色标记。

二叉查找树最坏查找次数是树的深度。其平均查找长度与树的形态有关，树的高度越高，平均查找长度越长，最佳情况是 O(log­2n)——树比较平衡的状态，而最坏情况是 O(n)——即退化成为线性顺序查找。

* AVL树：一般是用平衡因子差值决定并通过旋转来实现，左右子树树高差不超过1，那么和红黑树比较它是严格的平衡二叉树，平衡条件非常严格（树高差只有1），只要插入或删除不满足上面的条件就要通过旋转来保持平衡。由于旋转是非常耗费时间的。我们可以推出AVL树适合用于插入删除次数比较少，但查找多的情况。
* 红黑树：通过对任何一条从根到叶子的简单路径上各个节点的颜色进行约束，确保没有一条路径会比其他路径长2倍，因而是近似平衡的。所以相对于严格要求平衡的AVL树来说，它的旋转保持平衡次数较少。用于搜索时，插入删除次数多的情况下我们就用红黑树来取代AVL。

AVL是一种高度平衡的二叉树，所以通常的结果是，维护这种高度平衡所付出的代价比从中获得的效率收益还大，故而实际的应用不多，更多的地方是用追求局部而不是非常严格整体平衡的红黑树。红黑树平衡度没AVL那么好。也就是说，如果从高度差来说，红黑树是大于AVL的，其实也就代表着它的实际查询时间(最坏情况)略逊于AVL的。数学证明红黑树的最大深度是 2log(2n+1), 其实最差情况它从根到叶子的最长路可以是最短路的两倍，但也不是很差，所以它的查询时间复杂度也是O（log n）。当然，如果场景中对插入删除不频繁，只是对查找特别有要求，AVL还是优于红黑的。

* 如果要较真比较性能的话，如果是有大量查询的场合，AVL可能好一些；不过如果要维护动态树结构的话，红黑树通常更好，因为对平衡性的要求不是那么严格，树结构变化时调整的次数相对较少。

windows对进程地址空间的管理用到了AVL树。红黑树广泛用在C++的STL中，如map和set都是用红黑树实现的。

3. B树与B+树：在大规模数据、持久化存储场景中，如果希望在保持O(logn)查找效率的情况下，同时减少每次查询IO操作的次数，可以使用B+树。

* 时间复杂度：查找、插入和删除在平均和最坏情况下都是O（log n）
* 空间复杂度：O(n)，因为有指针（B树还有关键字）

大规模数据的持久化存储中，二叉查找树、AVL和红黑树结构由于树的深度过大而造成磁盘I/O读写过于频繁，进而导致查询效率低下。那么如何减少树的深度，一个基本的想法就是：采用多叉树结构。

> 以数据库索引的存储结构设计来举例。我们给一亿个数据构建二叉查找树索引，那索引中会包含大约 1 亿个节点，每个节点假设占用 16 个字节，那就需要大约 1GB 的内存空间。给一张表建立索引，我们需要 1GB 的内存空间。如果我们要给 10 张表建立索引，那对内存的需求是无法满足的。如何解决这个索引占用太多内存的问题呢？
> 我们可以借助时间换空间的思路，把索引存储在硬盘中，而非内存中。我们都知道，硬盘是一个非常慢速的存储设备。通常内存的访问速度是纳秒级别的，而磁盘访问的速度是毫秒级别的。读取同样大小的数据，从磁盘中读取花费的时间，是从内存中读取所花费时间的上万倍，甚至几十万倍。
> 这种将索引存储在硬盘中的方案，尽管减少了内存消耗，但是在数据查找的过程中，需要读取磁盘中的索引，因此数据查询效率就相应降低很多。
> 不过，为了节省内存，如果把树存储在硬盘中，那么每个节点的读取（或者访问），都对应一次磁盘 IO 操作。树的高度就等于每次查询数据时磁盘 IO 操作的次数。
> 我们来看下，如果我们把索引构建成 m 叉树，高度是不是比二叉树要小呢？比如，给 16 个数据构建二叉树索引，树的高度是 4，查找一个数据，就需要 4 个磁盘 IO 操作（如果根节点存储在内存中，其他结点存储在磁盘中），如果对 16 个数据构建五叉树索引，那高度只有 2，查找一个数据，对应只需要 2 次磁盘操作。如果 m 叉树中的 m 是 100，那对一亿个数据构建索引，树的高度也只是 3，最多只要 3 次磁盘 IO 就能获取到数据。磁盘 IO 变少了，查找数据的效率也就提高了。

B/B+ 树就是N叉（N-ary）平衡树，每个节点可以有更多的孩子，新的值可以插在已有的节点里，而不需要改变树的高度，从而大量减少重新平衡和数据迁移的次数，这非常适合做数据库索引这种需要持久化在磁盘，同时需要大量查询和插入操作的应用。

B树与B+树用在磁盘文件组织、数据索引和数据库索引。

4. 散列表：查找效率更高O(1)，但是存在空间浪费，并且Hash表本身是无序的，没办法进行区间查找。

* 红黑树查找和删除的时间复杂度都是O(logn)，Hash查找和删除的时间复杂度都是O(1)。
* 树表是有序的，Hash表是无序的
* 红黑树占用的内存更小（仅需要为其存在的节点分配内存），而Hash事先就应该分配足够的内存存储散列表（即使有些槽可能遭弃用）。

## 参考 ##

https://www.zhihu.com/question/30527705/answer/259948086，韦易笑
