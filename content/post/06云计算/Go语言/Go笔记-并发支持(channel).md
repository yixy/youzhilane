---
categories:
- 云计算
date: "2019-06-25T09:42:41+08:00"
lastmod: "2019-10-02T17:04:22+08:00"
tags:
- 云计算
- Golang
title: Go笔记-并发支持(channel)
---

## 0. channel ##

channel是 Go 语言自带的、唯一一个可以满足并发安全性的类型。

Golang 推荐通过 channel 进行通信和同步，即CSP（Communicating Sequential Processes）并发控制方式。

> Don’t communicate by sharing memory; share memory by communicating.

## 1.非缓冲channel与缓冲channel ##

channel是类型相关的。一个channel只能传递一种类型的值，这个类型需要在声明channel时指定。channel可以分为非缓冲的和缓冲的通道。

一个通道（channel）相当于一个先进先出（FIFO）的队列。也就是说，通道中的各个元素值都是严格地按照发送的顺序排列的，先被发送通道的元素一定会被先接收。

```
//声明channel
var ch chan int
//声明并初始化channel
ch:=make(chan int)
//数据发送至channel，这通常会导致程序阻塞，直到有其他goroutine从这个channel中读取数据
ch<-1
//从channel中读取数据
value:=<-ch
//关闭channel
close(ch)

//带缓冲的channel，在缓冲区被填满之前都不会引发阻塞操作
c:=make(chan int,1024)

ch1:=make(chan int)
//ch2是一个单向的读取channel
ch2:=<-chan int(ch1)
//ch3是一个单向的写入channel
ch3:=chan<- int(ch1)
```

## 2. channel的特性 ##

顺序性和并发安全

* 一个通道（channel）相当于一个先进先出（FIFO）的队列。也就是说，通道中的各个元素值都是严格地按照发送的顺序排列的，先被发送通道的元素一定会被先接收。
* 通道类型的值本身就是并发安全的，这也是 Go 语言自带的、唯一一个可以满足并发安全性的类型。

如何保证并发安全

* 同一个通道的发送操作之间是互斥的：在同一时刻，Golang语言的运行时系统针对同一个通道，只会执行其任意个发送操作中的某一个，直到这个元素被完全复制进通道之后，其他针对该通道的发送操作才会执行。
* 发送操作是原子性的：元素值从外界进入通道时会被复制，所以通道中的是值的副本。在发送步骤完成前，发送代码会一直阻塞。
* 同一个通道的接收操作之间是互斥的：在同一时刻，Golang语言的运行时系统针对同一个通道，只会执行其任意个接收操作中的某一个，直到这个元素被完全移出通道之后，其他针对该通道的接收操作才会被执行。
* 接收操作是原子性的：元素从通道进入外界时会被移动，即1）先复制通道中的值并发给接收方；2）删除通道中的值。在接收步骤完成前，接收代码会一直阻塞。
* 显然的，对于通道内的同一个元素来说，发送先接收后，所以其发送和接收操作是互斥的。

缓冲阻塞机制

* 通道的零值就是nil，对于值为nil的通道，无论它的具体类型是什么，对它的发送操作和接收操作都会永久处于阻塞状态。
* 对正常初始化过的缓冲通道来说，如果通道已满，那么对它的所有发送操作都会阻塞，直到通道中的元素被接收走。这时，通道会优先通知最早因此而等待的发送者，后者会再次执行发送操作。相反的，如果通道已空，那么对它的所有接受操作都会被阻塞，直到通道中有新的元素出现。这时，通道会通知最早等待的那个接收者，并使它再次执行接收操作。
* 对于正常初始化过的非缓冲通道，无论是发送还是接收操作，一开始执行时就会被阻塞，直到配对的操作也开始执行。

一般不要让接收方关闭通道，而应当让发送方关闭。利用通道关闭的广播机制通知接收方。

* v,ok<-ch，ok为bool值，true表示正常接收，false表示通道关闭。注意，如果通道关闭时，里面还有元素未被取出，那么接收表达式的第一个结果仍会是通道中的元素值，而第二个结果一定会是true。因此，通过表达式的第二个结果值判断通道是否关闭可能是有延迟的。
* 通道关闭时会对所有接受者进行广播：所有的channel接收者都会在channel关闭时，立刻从阻塞等等待中返回且上述ok值为false。这个广播机制经常被利用，进行多个订阅者同时发送信息。如退出信号。
* 向关闭的channel发送数据会导致Panic
* 试图关闭一个已关闭的通道也会引发panic。

## 3. 单向通道 ##

如果我们把操作符`<-`用在通道的类型声明中，那么它代表的就不是“发送”或“接收”的动作了，而是表示通道的方向。单向通道存在的意义在于“约束”，也就是对代码的约束。

顺便说一下，我们在调用SendInt函数的时候，只需要把一个元素类型匹配的双向通道传给它就行了，没必要用发送通道，因为 Go 语言在这种情况下会自动地把双向通道转换为函数所需的单向通道。


```
type Notifier interface {
 SendInt(ch chan<- int)
}
intChan1 := make(chan int, 3)
SendInt(intChan1)
```
